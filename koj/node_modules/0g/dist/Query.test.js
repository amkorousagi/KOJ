"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var ArchetypeManager_1 = require("./ArchetypeManager");
var Entity_1 = require("./Entity");
var filters_1 = require("./filters");
var Query_1 = require("./Query");
var componentFixtures_1 = require("./__tests__/componentFixtures");
var withA = 100;
var withAB = 101;
var withB = 102;
var withC = 103;
var withD = 104;
var withAD = 105;
describe('Query', function () {
    var game = null;
    // bootstrapping
    function addEntity(eid, components) {
        game.archetypeManager.createEntity(eid);
        components.forEach(function (comp) {
            game.archetypeManager.addComponent(eid, comp);
        });
    }
    beforeEach(function () {
        var archetypeManager = new ArchetypeManager_1.ArchetypeManager({
            componentManager: {
                componentTypes: {
                    length: 10,
                },
                getTypeName: function () { return 'TEST MOCK'; },
            },
            entityPool: {
                acquire: function () {
                    return new Entity_1.Entity();
                },
                release: function () { },
            },
        });
        game = new events_1.EventEmitter();
        game.archetypeManager = archetypeManager;
        game.entityPool = {
            acquire: function () {
                return new Entity_1.Entity();
            },
            release: function () { },
        };
        // bootstrap some testing archetypes
        addEntity(withA, [new componentFixtures_1.ComponentA()]);
        addEntity(withB, [new componentFixtures_1.ComponentB()]);
        addEntity(withAB, [new componentFixtures_1.ComponentA(), new componentFixtures_1.ComponentB()]);
        addEntity(withC, [new componentFixtures_1.ComponentC()]);
        addEntity(withD, [new componentFixtures_1.ComponentD()]);
        addEntity(withAD, [new componentFixtures_1.ComponentA(), new componentFixtures_1.ComponentD()]);
    });
    it('registers Archetypes which match included components', function () {
        var e_1, _a;
        var query = new Query_1.Query(game);
        query.initialize([componentFixtures_1.ComponentA]);
        expect.assertions(4);
        expect(query.archetypeIds).toEqual([
            '01000000000',
            '01100000000',
            '01001000000',
        ]);
        try {
            for (var query_1 = __values(query), query_1_1 = query_1.next(); !query_1_1.done; query_1_1 = query_1.next()) {
                var ent = query_1_1.value;
                expect(ent.get(componentFixtures_1.ComponentA)).not.toBe(null);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (query_1_1 && !query_1_1.done && (_a = query_1.return)) _a.call(query_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    });
    it('registers Archetypes which omit excluded components', function () {
        var e_2, _a;
        var query = new Query_1.Query(game);
        query.initialize([componentFixtures_1.ComponentA, filters_1.not(componentFixtures_1.ComponentB)]);
        expect.assertions(5);
        expect(query.archetypeIds).toEqual(['01000000000', '01001000000']);
        try {
            for (var query_2 = __values(query), query_2_1 = query_2.next(); !query_2_1.done; query_2_1 = query_2.next()) {
                var ent = query_2_1.value;
                expect(ent.get(componentFixtures_1.ComponentA)).not.toBe(null);
                expect(ent.get(componentFixtures_1.ComponentB)).toBe(null);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (query_2_1 && !query_2_1.done && (_a = query_2.return)) _a.call(query_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
    });
    it('registers late-added Archetypes', function () {
        var e_3, _a;
        var query = new Query_1.Query(game);
        query.initialize([componentFixtures_1.ComponentB]);
        addEntity(200, [new componentFixtures_1.ComponentB(), new componentFixtures_1.ComponentD()]);
        addEntity(201, [new componentFixtures_1.ComponentC(), new componentFixtures_1.ComponentD()]);
        expect.assertions(4);
        expect(query.archetypeIds).toEqual([
            '00100000000',
            '01100000000',
            '00101000000',
        ]);
        try {
            for (var query_3 = __values(query), query_3_1 = query_3.next(); !query_3_1.done; query_3_1 = query_3.next()) {
                var ent = query_3_1.value;
                expect(ent.get(componentFixtures_1.ComponentB)).not.toBe(null);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (query_3_1 && !query_3_1.done && (_a = query_3.return)) _a.call(query_3);
            }
            finally { if (e_3) throw e_3.error; }
        }
    });
    it('maintains a list of matching entities', function () {
        var onAdded = jest.fn();
        var onRemoved = jest.fn();
        var query = new Query_1.Query(game);
        query.on('entityAdded', onAdded);
        query.on('entityRemoved', onRemoved);
        query.initialize([componentFixtures_1.ComponentA]);
        expect(query.entities).toEqual([withA, withAB, withAD]);
        expect(query.addedIds).toEqual([withA, withAB, withAD]);
        expect(onAdded).toHaveBeenCalledTimes(3);
        // reset frame tracking
        game.emit('preApplyOperations');
        onAdded.mockClear();
        expect(query.entities).toEqual([withA, withAB, withAD]);
        expect(query.addedIds).toEqual([]);
        expect(query.removedIds).toEqual([]);
        // simple add case
        game.archetypeManager.addComponent(withC, new componentFixtures_1.ComponentA());
        game.emit('stepComplete');
        expect(query.entities).toEqual([withA, withAB, withAD, withC]);
        expect(query.addedIds).toEqual([withC]);
        expect(query.removedIds).toEqual([]);
        expect(onAdded).toHaveBeenCalledTimes(1);
        game.emit('preApplyOperations');
        onAdded.mockClear();
        expect(query.entities).toEqual([withA, withAB, withAD, withC]);
        expect(query.addedIds).toEqual([]);
        expect(query.removedIds).toEqual([]);
        // simple remove case
        game.archetypeManager.removeComponent(withAD, componentFixtures_1.ComponentA.id);
        game.emit('stepComplete');
        expect(query.entities).toEqual([withA, withAB, withC]);
        expect(query.addedIds).toEqual([]);
        expect(query.removedIds).toEqual([withAD]);
        expect(onRemoved).toHaveBeenCalledTimes(1);
        game.emit('preApplyOperations');
        onAdded.mockClear();
        expect(query.entities).toEqual([withA, withAB, withC]);
        expect(query.addedIds).toEqual([]);
        expect(query.removedIds).toEqual([]);
        // internal move archetype case
        game.archetypeManager.addComponent(withA, new componentFixtures_1.ComponentC());
        game.emit('stepComplete');
        expect(query.entities).toEqual([withAB, withC, withA]);
        expect(query.addedIds).toEqual([]);
        expect(query.removedIds).toEqual([]);
        expect(onAdded).not.toHaveBeenCalled();
    });
    describe('events', function () {
        var query;
        var onAdded = jest.fn();
        var onRemoved = jest.fn();
        beforeEach(function () {
            query = new Query_1.Query(game);
            query.initialize([componentFixtures_1.ComponentA]);
            query.on('entityAdded', onAdded);
            query.on('entityRemoved', onRemoved);
            game.emit('preApplyOperations');
        });
        it('emits entityAdded events when an entity is added to matching Archetype', function () {
            addEntity(200, [new componentFixtures_1.ComponentA()]);
            addEntity(201, [new componentFixtures_1.ComponentA(), new componentFixtures_1.ComponentC()]);
            addEntity(202, [new componentFixtures_1.ComponentD()]);
            game.emit('stepComplete');
            expect(onAdded).toHaveBeenCalledTimes(2);
            expect(onAdded).toHaveBeenNthCalledWith(1, 200);
            expect(onAdded).toHaveBeenNthCalledWith(2, 201);
        });
        it('emits entityRemoved events when an entity is removed from matching Archetype', function () {
            game.archetypeManager.removeComponent(withAB, componentFixtures_1.ComponentA.id);
            game.emit('stepComplete');
            expect(onRemoved).toHaveBeenCalledWith(withAB);
            expect(onAdded).not.toHaveBeenCalled();
        });
        it('does not emit added/removed when entity is moved between matching Archetypes', function () {
            game.archetypeManager.removeComponent(withAB, componentFixtures_1.ComponentB.id);
            expect(onRemoved).not.toHaveBeenCalled();
            expect(onAdded).not.toHaveBeenCalled();
        });
    });
});
//# sourceMappingURL=Query.test.js.map