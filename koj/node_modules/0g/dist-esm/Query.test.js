var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
import { EventEmitter } from 'events';
import { ArchetypeManager } from './ArchetypeManager';
import { Entity } from './Entity';
import { not } from './filters';
import { Query } from './Query';
import { ComponentA, ComponentB, ComponentC, ComponentD, } from './__tests__/componentFixtures';
var withA = 100;
var withAB = 101;
var withB = 102;
var withC = 103;
var withD = 104;
var withAD = 105;
describe('Query', function () {
    var game = null;
    // bootstrapping
    function addEntity(eid, components) {
        game.archetypeManager.createEntity(eid);
        components.forEach(function (comp) {
            game.archetypeManager.addComponent(eid, comp);
        });
    }
    beforeEach(function () {
        var archetypeManager = new ArchetypeManager({
            componentManager: {
                componentTypes: {
                    length: 10,
                },
                getTypeName: function () { return 'TEST MOCK'; },
            },
            entityPool: {
                acquire: function () {
                    return new Entity();
                },
                release: function () { },
            },
        });
        game = new EventEmitter();
        game.archetypeManager = archetypeManager;
        game.entityPool = {
            acquire: function () {
                return new Entity();
            },
            release: function () { },
        };
        // bootstrap some testing archetypes
        addEntity(withA, [new ComponentA()]);
        addEntity(withB, [new ComponentB()]);
        addEntity(withAB, [new ComponentA(), new ComponentB()]);
        addEntity(withC, [new ComponentC()]);
        addEntity(withD, [new ComponentD()]);
        addEntity(withAD, [new ComponentA(), new ComponentD()]);
    });
    it('registers Archetypes which match included components', function () {
        var e_1, _a;
        var query = new Query(game);
        query.initialize([ComponentA]);
        expect.assertions(4);
        expect(query.archetypeIds).toEqual([
            '01000000000',
            '01100000000',
            '01001000000',
        ]);
        try {
            for (var query_1 = __values(query), query_1_1 = query_1.next(); !query_1_1.done; query_1_1 = query_1.next()) {
                var ent = query_1_1.value;
                expect(ent.get(ComponentA)).not.toBe(null);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (query_1_1 && !query_1_1.done && (_a = query_1.return)) _a.call(query_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    });
    it('registers Archetypes which omit excluded components', function () {
        var e_2, _a;
        var query = new Query(game);
        query.initialize([ComponentA, not(ComponentB)]);
        expect.assertions(5);
        expect(query.archetypeIds).toEqual(['01000000000', '01001000000']);
        try {
            for (var query_2 = __values(query), query_2_1 = query_2.next(); !query_2_1.done; query_2_1 = query_2.next()) {
                var ent = query_2_1.value;
                expect(ent.get(ComponentA)).not.toBe(null);
                expect(ent.get(ComponentB)).toBe(null);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (query_2_1 && !query_2_1.done && (_a = query_2.return)) _a.call(query_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
    });
    it('registers late-added Archetypes', function () {
        var e_3, _a;
        var query = new Query(game);
        query.initialize([ComponentB]);
        addEntity(200, [new ComponentB(), new ComponentD()]);
        addEntity(201, [new ComponentC(), new ComponentD()]);
        expect.assertions(4);
        expect(query.archetypeIds).toEqual([
            '00100000000',
            '01100000000',
            '00101000000',
        ]);
        try {
            for (var query_3 = __values(query), query_3_1 = query_3.next(); !query_3_1.done; query_3_1 = query_3.next()) {
                var ent = query_3_1.value;
                expect(ent.get(ComponentB)).not.toBe(null);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (query_3_1 && !query_3_1.done && (_a = query_3.return)) _a.call(query_3);
            }
            finally { if (e_3) throw e_3.error; }
        }
    });
    it('maintains a list of matching entities', function () {
        var onAdded = jest.fn();
        var onRemoved = jest.fn();
        var query = new Query(game);
        query.on('entityAdded', onAdded);
        query.on('entityRemoved', onRemoved);
        query.initialize([ComponentA]);
        expect(query.entities).toEqual([withA, withAB, withAD]);
        expect(query.addedIds).toEqual([withA, withAB, withAD]);
        expect(onAdded).toHaveBeenCalledTimes(3);
        // reset frame tracking
        game.emit('preApplyOperations');
        onAdded.mockClear();
        expect(query.entities).toEqual([withA, withAB, withAD]);
        expect(query.addedIds).toEqual([]);
        expect(query.removedIds).toEqual([]);
        // simple add case
        game.archetypeManager.addComponent(withC, new ComponentA());
        game.emit('stepComplete');
        expect(query.entities).toEqual([withA, withAB, withAD, withC]);
        expect(query.addedIds).toEqual([withC]);
        expect(query.removedIds).toEqual([]);
        expect(onAdded).toHaveBeenCalledTimes(1);
        game.emit('preApplyOperations');
        onAdded.mockClear();
        expect(query.entities).toEqual([withA, withAB, withAD, withC]);
        expect(query.addedIds).toEqual([]);
        expect(query.removedIds).toEqual([]);
        // simple remove case
        game.archetypeManager.removeComponent(withAD, ComponentA.id);
        game.emit('stepComplete');
        expect(query.entities).toEqual([withA, withAB, withC]);
        expect(query.addedIds).toEqual([]);
        expect(query.removedIds).toEqual([withAD]);
        expect(onRemoved).toHaveBeenCalledTimes(1);
        game.emit('preApplyOperations');
        onAdded.mockClear();
        expect(query.entities).toEqual([withA, withAB, withC]);
        expect(query.addedIds).toEqual([]);
        expect(query.removedIds).toEqual([]);
        // internal move archetype case
        game.archetypeManager.addComponent(withA, new ComponentC());
        game.emit('stepComplete');
        expect(query.entities).toEqual([withAB, withC, withA]);
        expect(query.addedIds).toEqual([]);
        expect(query.removedIds).toEqual([]);
        expect(onAdded).not.toHaveBeenCalled();
    });
    describe('events', function () {
        var query;
        var onAdded = jest.fn();
        var onRemoved = jest.fn();
        beforeEach(function () {
            query = new Query(game);
            query.initialize([ComponentA]);
            query.on('entityAdded', onAdded);
            query.on('entityRemoved', onRemoved);
            game.emit('preApplyOperations');
        });
        it('emits entityAdded events when an entity is added to matching Archetype', function () {
            addEntity(200, [new ComponentA()]);
            addEntity(201, [new ComponentA(), new ComponentC()]);
            addEntity(202, [new ComponentD()]);
            game.emit('stepComplete');
            expect(onAdded).toHaveBeenCalledTimes(2);
            expect(onAdded).toHaveBeenNthCalledWith(1, 200);
            expect(onAdded).toHaveBeenNthCalledWith(2, 201);
        });
        it('emits entityRemoved events when an entity is removed from matching Archetype', function () {
            game.archetypeManager.removeComponent(withAB, ComponentA.id);
            game.emit('stepComplete');
            expect(onRemoved).toHaveBeenCalledWith(withAB);
            expect(onAdded).not.toHaveBeenCalled();
        });
        it('does not emit added/removed when entity is moved between matching Archetypes', function () {
            game.archetypeManager.removeComponent(withAB, ComponentB.id);
            expect(onRemoved).not.toHaveBeenCalled();
            expect(onAdded).not.toHaveBeenCalled();
        });
    });
});
//# sourceMappingURL=Query.test.js.map