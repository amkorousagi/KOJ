import { Poolable } from './internal/objectPool';
export declare const COMPONENT_CHANGE_HANDLE: unique symbol;
declare type ComponentUpdateFn<T> = (updater: (self: T) => void) => void;
declare type ComponentInitializeFn<T> = (instance: T, overrides: Partial<T>, id: number) => void;
declare type ComponentSerialize<Comp> = (instance: Comp) => string;
declare type ComponentDeserialize<Comp> = (serialized: string, additionalProperties: PropertyDescriptorMap) => Comp;
export declare type ComponentInstance<T> = Poolable & T & {
    update: ComponentUpdateFn<T>;
    updated: boolean;
    id: number;
    __type: number;
    [COMPONENT_CHANGE_HANDLE]?: (self: T) => void;
};
export declare type BaseComponentType<T> = {
    new (): ComponentInstance<T>;
    id: number;
    defaults: () => T;
    initialize: ComponentInitializeFn<T>;
};
export interface SerializedComponentType<T> extends BaseComponentType<T> {
    serialize: ComponentSerialize<T>;
    deserialize: ComponentDeserialize<T>;
    serialized: true;
}
export interface UnserializedComponentType<T> extends BaseComponentType<T> {
    serialized: false;
}
export declare type ComponentType<T> = SerializedComponentType<T> | UnserializedComponentType<T>;
export declare function Component<T>(defaults: () => T, { serialize, deserialize, }?: {
    serialize?: ComponentSerialize<T>;
    deserialize?: ComponentDeserialize<T>;
}): SerializedComponentType<T>;
export declare function State<T>(defaults: () => T): UnserializedComponentType<T>;
export declare type ComponentInstanceFor<T extends ComponentType<any>> = T extends ComponentType<infer Shape> ? ComponentInstance<Shape> : never;
export {};
